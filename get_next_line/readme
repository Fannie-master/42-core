static 
✅ 示例 1: 函数内的静态变量
#include <stdio.h>

void countCalls() {
    static int count = 0;  // Static variable
    count++;
    printf("This function is called %d times.\n", count);
}

int main() {
    countCalls();  // Output: 1
    countCalls();  // Output: 2
    countCalls();  // Output: 3
    return 0;
}
🔍说明：
count被声明为static, 因此它在函数调用之间保持其值。
如果它是正常的int count = 0, 则每次函数运行时它都会重置为 0。so 1 2 3 will become 1 1 1

✅ 示例 2: 具有文件作用域的静态变量（函数外部）
#include <stdio.h>

static int globalVar = 10;  // Static global variable (only accessible in this file)

void show() {
    printf("globalVar = %d\n", globalVar);
}

int main() {
    show();
    return 0;
}
🔍说明：
static全局变量仅限于当前文件。
如果没有static, globalVar可以使用从其他文件访问extern。

✅ 示例 3: 与非静态变量进行比较
#include <stdio.h>

void testStatic() {
    static int x = 0;
    x++;
    printf("Static x = %d\n", x);
}

void testAuto() {
    int y = 0;  // Normal auto (non-static) variable
    y++;
    printf("Auto y = %d\n", y);
}

int main() {
    for(int i = 0; i < 3; i++) {
        testStatic();
        testAuto();
    }
    return 0;
}
🔍输出：
Static x = 1
Auto y = 1
Static x = 2
Auto y = 1
Static x = 3
Auto y = 1
📌说明：
x是static——它保留了它的价值。
y是一个普通变量——每次函数运行时它都会重置。

🔶🌟 核心理念和逻辑
🔸G
编写一个 C 函数：
读一行（以 结尾\n）f.txt文件或
返回
重复调用将返回下一行。
当不再存在行时, 它返回NULL。

📌 整体流程图：

文件 -> 缓冲区（Buffer） -> 暂存区（Static/动态） -> 找到'\n' -> 返回一行


✅ 分步骤讲解实现思路（以 C 语言为例）

🔹 1. 使用一个缓冲区读取文件内容
	•	每次用 read(fd, buffer, BUFFER_SIZE) 读取一定数量的字节
	•	BUFFER_SIZE 通常是宏定义，如 1024、42 等

🔹 2. 保存未处理的残余内容
	•	由于一行可能跨多次 read() 才完整，所以要用一个 static char *stash 或动态内存来暂存还没处理的内容

🔹 3. 判断 stash 中是否包含 \n
	•	如果有，表示可以从中截取出一整行
	•	如果没有，就继续 read() 更多内容进来，直到有 \n 或 EOF

🔹 4. 截取并返回一行
	•	分离出一行（包含 \n，如果存在）
	•	把剩下的内容继续留在 stash 里，留给下次调用处理

🔹 5. 特别处理 EOF 和错误
	•	如果 read() 返回 0：说明到达文件末尾
	•	如果返回 -1：表示读取出错